APK WhiteLabel Studio - Setup and Deployment

1. Prerequisites
   - Docker and Docker Compose installed.
   - Node.js 20+ and npm (for local frontend/backend dev outside Docker, if desired).
   - Access to Azure resources (Blob Storage, PostgreSQL, Redis or Azure Cache for Redis, Container Apps/Web Apps).

2. Environment configuration
   Backend:
     - Copy backend/.env.example to backend/.env
     - Set:
       - DATABASE_URL=postgresql://postgres:postgres@db:5432/apk_whitelabel (or your Azure Postgres URL in production)
       - JWT_SECRET=your-strong-jwt-secret
       - REDIS_URL=redis://redis:6379 (or your Azure Cache for Redis connection)
       - FRONTEND_ORIGIN=http://localhost:3000 (or your deployed frontend URL)
       - AZURE_STORAGE_CONNECTION_STRING=connection string for your Azure Storage account
       - AZURE_STORAGE_CONTAINER=apk-whitelabel-uploads (or another container name)
       - WORKER_SERVICE_URL=http://worker:5000
       - BACKEND_INTERNAL_TOKEN=strong-random-string

   Worker:
     - Copy worker/.env.example to worker/.env
     - Set:
       - BACKEND_API_URL=http://backend:4000
       - BACKEND_API_TOKEN must match BACKEND_INTERNAL_TOKEN from backend/.env
       - AZURE_STORAGE_CONNECTION_STRING and AZURE_STORAGE_CONTAINER for build outputs
       - REDIS_URL if you later extend worker with Redis features
       - BUILD_WORK_DIR=/app/workdir

   Frontend:
     - Copy frontend/.env.example to frontend/.env
     - Set:
       - NEXT_PUBLIC_API_BASE_URL=http://localhost:4000/api (or your backend URL + /api)
       - NEXT_PUBLIC_WS_URL=http://localhost:4000 (or your backend WebSocket URL)

3. Local development (Docker)
   - From the project root:
     - cd docker
     - docker compose up --build
   - The stack starts:
     - Postgres on 5432
     - Redis on 6379
     - Backend API on 4000
     - Worker service on 5000
     - Frontend on 3000
   - Run Prisma migrations inside the backend container:
     - docker compose exec backend npx prisma migrate dev --name init

4. Local development (without Docker, optional)
   - Start Postgres and Redis locally and set DATABASE_URL and REDIS_URL in backend/.env
   - Backend:
     - cd backend
     - npm install
     - npx prisma generate
     - npx prisma migrate dev --name init
     - npm run dev
   - Worker:
     - cd worker
     - python -m venv .venv && source .venv/bin/activate
     - pip install -r requirements.txt
     - python -m src.main
   - Frontend:
     - cd frontend
     - npm install
     - npm run dev

5. Production build flow
   - Backend:
     - In CI, run:
       - cd backend
       - npm ci
       - npx prisma generate
       - npm run build
     - Build Docker image using docker/Dockerfile.backend
   - Worker:
     - In CI, run:
       - cd worker
       - pip install -r requirements.txt
       - Run tests/linting if desired
     - Build Docker image using docker/Dockerfile.worker
   - Frontend:
     - In CI, run:
       - cd frontend
       - npm ci
       - npm run build
     - Build Docker image using docker/Dockerfile.frontend

6. Azure deployment (high-level)
   - Storage:
     - Create an Azure Storage account.
     - Create two containers:
       - One for uploads (e.g. apk-whitelabel-uploads) for incoming APK/source zips.
       - One for outputs (e.g. apk-whitelabel-outputs) for built artifacts.
     - Copy the connection string into backend/.env and worker/.env.

   - Database:
     - Create Azure Database for PostgreSQL.
     - Create a database (e.g. apk_whitelabel).
     - Set DATABASE_URL in backend configuration, then run Prisma migrations:
       - From a container or CI job: npx prisma migrate deploy

   - Redis:
     - Create Azure Cache for Redis.
     - Configure REDIS_URL for backend (and worker if needed) with the SSL-enabled connection string.

   - Containers:
     - Option A: Azure Container Apps
       - Push images for backend, worker, and frontend to Azure Container Registry.
       - Create three Container Apps:
         - backend-app (expose port 4000, HTTP and WebSocket)
         - worker-app (internal only, port 5000)
         - frontend-app (port 3000)
       - Set environment variables in each Container App to match your .env values.
       - Configure ingress for frontend-app and backend-app; ensure frontend NEXT_PUBLIC_API_BASE_URL and NEXT_PUBLIC_WS_URL target backend ingress URL.
     - Option B: Azure Web App for Containers
       - Create separate Web Apps for backend and frontend, and another for worker.
       - Attach images from Azure Container Registry.
       - Configure app settings (env vars) the same way as in .env files.

   - Networking and security:
     - Restrict workerâ€™s /build endpoint to internal network only (no public ingress).
     - Use HTTPS-only endpoints for frontend and backend.
     - Rotate JWT_SECRET and BACKEND_INTERNAL_TOKEN periodically and store them in Azure Key Vault, referencing them from your container environment.

7. Usage flow
   - Register or log in via the frontend.
   - Create a project in the dashboard.
   - Add one or more flavors under the project (each with its own branding config).
   - Upload an APK or source ZIP and queue builds from the Build page.
   - Follow real-time logs in the Build detail view and download signed artifacts when complete.

